# ------------------------------------------------

######## ##          ##  ####  ######  ##    ##
##       ##          ## ##  ##   ##   ####  ####
##        ##        ##  ##  ##   ##   ## #### ##
##        ##   ##   ## ########  ##  ##   ##   ##
##         ## #### ##  ##    ##  ##  ##        ##
##         ####  #### ##      ## ## ##          ##
##########  ##    ##  ##      ## ## ##          ##

[OPTIONS]
#-------------------------------------------------------
# OPTION - to switch on/off
#-------------------------------------------------------

TemperatureInKelvin = True
gridSizeUserDefined = True

#-----------------------------------------------
calc_evaporation = True
PET_modus = 1
includeIrrigation = True
includeWaterDemand = True
includeIndusDomesDemand = True
usingAllocSegments = False
limitAbstraction = True

sectorSourceAbstractionFractions = True
staticLandCoverMaps = True

using_reservoir_command_areas = True
using_lift_areas = False

includeCrops = True
use_GeneralCropnonIrr = 0
use_GeneralCropIrr = 0
activate_fallow = 1
leftoverIrrigatedCropIsRainfed = 0
activate_domestic_agents = True
activate_irrigation_agents = False
relax_irrigation_agents = False

automaticFallowingIrr = 0
moveIrrFallowToNonIrr = False

# Environmental Flow
calc_environflow = False

#-----------------------------------------------
# Soil 
# use preferential flow, that bypasses the soil matrix and drains directly to the groundwater (not for irrPaddy)
preferentialFlow = True
# Capillar rise
CapillarRise = True

# Groundwater calculation with Modflow
modflow_coupling = True
use_complex_solver_for_modflow = False

#-----------------------------------------------
# Routing

# if runoff concentration to the edge of a cell is included
includeRunoffConcentration = False
# Waterbodies like lakes and reservoirs
includeWaterBodies = True
# kinematic wave routing, if False no routing is calculated
includeRouting = True

#-----------------------------------------------
# Inflow from outside of the modelled area
inflow = False
waterquality = False

# --- Reporting & Debugging ------------------- ----------------------------------------------
# Reporting options
writeNetcdfStack = True
reportMap = True
reportTss = True
# Checking water balance (for debugging)
calcWaterBalance = False
sumWaterBalance = False




#-------------------------------------------------------
# DEFINITIONS OF PARAMETERS
#-------------------------------------------------------

#-------------------------------------------------------
[FILE_PATHS]
#-------------------------------------------------------
PathSystem = P:\watmodel\CWATM\upper_bhima\FUSE
#PathSystem = C:\Data\bhima_Input_mainCWatM
PathRoot = ./
PathOut = C:\nonGithub\Output
PathMaps = $(PathSystem)/Input
PathInit = $(PathMaps)/init
#PathWaterdemand = $(FILE_PATHS:PathMaps)/landsurface/waterDemand
PathMeteo = $(PathMaps)/meteo/010deg

#-------------------------------------------------------
[NETCDF_ATTRIBUTES]
institution = IIASA
title = CWatM presents Bhima 30sec featuring modflow
metaNetcdfFile = $(FILE_PATHS:PathSystem)/metaNetcdf.xml

#-------------------------------------------------------
# AREA AND OUTLETS
#-------------------------------------------------------
[MASK_OUTLET]

# Area mask
# A pcraster map, tif or netcdf map e.g.  $(FILE_PATHS:PathRoot)/data/areamaps/area_indus.map
# or a retancle: Number of Cols, Number of rows, cellsize, upper left corner X, upper left corner Y 
#MaskMap = $(FILE_PATHS:PathMaps)/areamaps/Upper_Bhima_mask.tif
MaskMap = $(FILE_PATHS:PathMaps)/areamaps/bhima.map
#MaskMap =  77 68 0.0833333333333 5.41666666666 52.0
#MaskMap =  75.89583 17.3875

#-------------------------------------------------------
# Station data
# either a map e.g. $(FILE_PATHS:PathRoot)/data/areamaps/area3.map
# or a location coordinates (X,Y) e.g. 5.75 52.25 9.25 49.75 )
# Lobith/Rhine
# Gauges Rhine: Lobith Maxau Cochem Kleinheubach Untersiggenthal Diepoldsau, Koblenz
#Gauges = 6.11 51.84 8.30 49.05 7.17 50.14 9.22 49.72 8.23 47.52 9.64 47.38 7.648 50.25
Gauges = 75.0075 17.9114
#Gauges= $(FILE_PATHS:PathMaps)/areamaps/rhine_station6.map

# if .tif file for gauges, this is a flag if the file is global or local
# e.g. Gauges = $(FILE_PATHS:PathRoot)/data/areamaps/gaugesRhine.tif
GaugesLocal = True

#-------------------------------------------------------
[TIME-RELATED_CONSTANTS]
#-------------------------------------------------------

#Ag Module
StepStart = 01/06/2013
SpinUp =  None
StepEnd =  10/06/2013

#StepStart = 01/06/1985
#SpinUp = 01/06/1990
#StepEnd =  01/06/2016

#StepStart = 01/06/1999
#SpinUp =  01/06/2000
#StepEnd =  01/06/2010

#-------------------------------------------------------
[INITITIAL CONDITIONS]
#-------------------------------------------------------

# for a warm start initial variables a loaded
# e.g for a start on 01/01/2010 load variable from 31/12/2009
load_initial = True
initLoad = $(FILE_PATHS:PathInit)/Bhima30sec_20120701.nc
save_initial = True
initSave = $(FILE_PATHS:PathInit)/Bhima30sec
StepInit = 01/07/2012
#-------------------------------------------------------
# CALIBARTION PARAMETERS
#-------------------------------------------------------
[CALIBRATION]

# These are parameter which are used for calibration
# could be any parameter, but for an easier overview, tehey are collected here
# in the calibration template a placeholder (e.g. 0.5647846144079458eta) instead of value

gwRiverMult = 1.0
SnowMeltCoef  = 0.004
runoffConc_factor  = 1.0
recessionCoeff_factor = 1.0
normalStorageLimit = 0.5
river_percent_factor = 0

#crop_correct  =  $(PathParameter)/params_crop.map
crop_correct = 0.9
#soildepth_factor = $(PathParameter)/params_soildepthF.map
soildepth_factor = 1.0465
#preferentialFlowConstant = $(PathParameter)/params_pref.map
preferentialFlowConstant = 2.5794
#arnoBeta_add = $(PathParameter)/params_arnoB.map 
arnoBeta_add = 0.728561
#factor_interflow = $(PathParameter)/params_interF.map
factor_interflow = 0.71619
#manningsN = $(PathParameter)/params_CCM.map
manningsN = 8.732
#lakeAFactor = $(PathParameter)/params_lakeAFactor.map
lakeAFactor = 0.54276
#lakeEvaFactor = $(PathParameter)/params_lakeEvaFactor.map
#lakeEvaFactor = 1.41
lakeEvaFactor = 1.2

#permeability = $(PathParameter)/params_permea.map
permeability = 1.2e-05
#permeability = 1.3e-05
#poro =  $(PathParameter)/params_poro.map
poro =  0.01758
#poro =  0.019

#-------------------------------------------------------
# TOPOGRAPHY MAPS
#-------------------------------------------------------
[TOPOP]
# local drain direction map (1-9)
Ldd = $(FILE_PATHS:PathMaps)/routing/ldd.tif
#Ldd = $(FILE_PATHS:PathMaps)/routing/ldd_totalend.nc
# Elevation map used for downscaling meteo maps
Elevation = $(FILE_PATHS:PathMaps)/landsurface/topo/dem_India_1km_extract.map
# Elevation standard deviation [m], i.e. altitude difference elevation within pixel.
# Used for sub-pixel modelling of snow accumulation and melt
ElevationStD = $(FILE_PATHS:PathMaps)/landsurface/topo/elvstd_UB_1km.nc

# Area of pixel [m2] (for lat/lon every cell has a different area)
CellArea  =  $(FILE_PATHS:PathMaps)/landsurface/topo/cellArea_m2_30s.tif
#CellArea  =  $(FILE_PATHS:PathMaps)/landsurface/topo/cellArea_totalend.nc

#-------------------------------------------------------
# INPUT METEOROLOGICAL TIMESERIES AS MAPS
#-------------------------------------------------------
[METEO]

# if meteo maps have the same scale than all the other maps e.g. 0.5 deg
meteomapssamescale = False
downscale_wordclim_tavg = $(FILE_PATHS:PathMaps)/meteo/worldclim/worldclim_tavg_UB.nc 
downscale_wordclim_tmin = $(FILE_PATHS:PathMaps)/meteo/worldclim/worldclim_tmin_UB.nc 
downscale_wordclim_tmax = $(FILE_PATHS:PathMaps)/meteo/worldclim/worldclim_tmax_UB.nc 
downscale_wordclim_prec = $(FILE_PATHS:PathMaps)/meteo/worldclim/worldclim_prec_UB.nc 
# if usemeteodownscaling = True (default if not set) meteo maps will be downscaled
# if usemeteodownscaling = False: meteomaps will be use as they come e.g. as 0.5 deg 
usemeteodownscaling = True
# precipitation [kg m-2 s-1]
PrecipitationMaps = $(FILE_PATHS:PathMeteo)/pr*
#PrecipitationMaps = $(FILE_PATHS:PathMeteo)/IMDpr_010deg.nc
# average daily temperature [K]
#TavgMaps = $(FILE_PATHS:PathMeteo)/tavg*
TavgMaps = $(FILE_PATHS:PathMeteo)/tas_*
# ----------------------------------------
# This is used if calc_evaporation = False

# daily reference evaporation (free water) 
E0Maps = $(FILE_PATHS:PathOut)/EWRef*
# daily reference evapotranspiration (crop) 
ETMaps = $(FILE_PATHS:PathOut)/ETRef*

# --------------------------------
# from kg m-2s-1 to m : 86.4
precipitation_coversion = 86.4
# from MM to m : 0.001
#precipitation_coversion = 0.001

evaporation_coversion = 1.00

# OUTPUT maps and timeseries
#OUT_Dir = $(FILE_PATHS:PathOut)
#OUT_MAP_Daily = Precipitation

#-------------------------------------------------------
# CALCULATE EVAPORATION - PENMAN - MONTEITH
#-------------------------------------------------------
[EVAPORATION]

# This is used if calc_evaporation = True
# use albedo maps
albedo = True
albedoMaps = $(FILE_PATHS:PathMaps)/landsurface/albedo/albedo_UB_1km.nc

# if not albedo maps use fixed albedo
# Albedo of bare soil surface (Supit et. al.)
AlbedoSoil = 0.15
# Albedo of water surface (Supit et. al.)ondu
AlbedoWater = 0.05
# Albedo of vegetation canopy (FAO,1998)
AlbedoCanopy = 0.23

# use specific humidity (TRUE) QAir,  or relative humidity (FALSE) - rhs
useHuss = True

# map stacks Temperature [K}]
TminMaps = $(FILE_PATHS:PathMeteo)/tasmin*
TmaxMaps = $(FILE_PATHS:PathMeteo)/tasmax*
# Instantaneous surface pressure[Pa]
PSurfMaps = $(FILE_PATHS:PathMeteo)/ps*
# 2 m istantaneous specific humidity[kg /kg] (QAir) or relative humidity [%] (rhs)
QAirMaps  =  $(FILE_PATHS:PathMeteo)/huss*
#RhsMaps = $(FILE_PATHS:PathMeteo)/hurs*
# wind speed maps at 10m [m/s]
WindMaps = $(FILE_PATHS:PathMeteo)/wind*
# radiation surface downwelling shortwave maps  [W/m2]
RSDSMaps = $(FILE_PATHS:PathMeteo)/rsds*
# radiation surface downwelling longwave maps [W/m2] [W/m2]
RSDLMaps = $(FILE_PATHS:PathMeteo)/rlds*

# OUTPUT maps and timeseries
#OUT_Dir = $(FILE_PATHS:PathOut)
#OUT_MAP_Daily = ETRef, EWRef

#-------------------------------------------------------
[SNOW]
#-------------------------------------------------------

# Number of vertical Snow layers
NumberSnowLayers = 1
# up to which layer the ice melt is calculated with the middle temperature
GlacierTransportZone = 1

# Temperature lapse rate with altitude [deg C / m]
TemperatureLapseRate = 0.0065 
# Multiplier applied to precipitation that falls as snow
SnowFactor = 1.0
# Range [m C-1 d-1] of the seasonal variation, SnowMeltCoef is the average value
SnowSeasonAdj = 0.001
# Average temperature at which snow melts
TempMelt =1.0
# Average temperature below which precipitation is snow
TempSnow = 1.0
# Snow melt coefficient: default: 4.0 
# SRM: 0.0045 m/C/day ( = 4.50 mm/C/day), Kwadijk: 18 mm/C/month (= 0.59 mm/C/day)  
# See also Martinec et al., 1998.

# use in CALIBRATION -> copied to CALIBRATION
#SnowMeltCoef = 0.004
IceMeltCoef  = 0.007

#--------------------------------------------------------------
# INITIAL CONDITIONS - Initial snow depth in snow zone 1-7 [mm]  - SnowCoverIni

[FROST]
# Snow water equivalent, (based on snow density of 450 kg/m3) (e.g. Tarboton and Luce, 1996)
SnowWaterEquivalent = 0.45
# Daily decay coefficient, (Handbook of Hydrology, p. 7.28)
Afrost = 0.97
# Snow depth reduction coefficient, [cm-1], (HH, p. 7.28)
Kfrost = 0.57
# Degree Days Frost Threshold (stops infiltration, percolation and capillary rise)
# Molnau and Bissel found a value 56-85 for NW USA.
FrostIndexThreshold = 56

#--------------------------------------------------------------
# INITIAL CONDITIONS: FrostIndexIni

[VEGETATION]
cropgroupnumber  =  $(FILE_PATHS:PathMaps)/soil/cropgrp_UB_1km.nc
#cropgroupnumber = 2.0
# soil water depletion fraction, Van Diepen et al., 1988: WOFOST 6.0, p.86, Doorenbos et. al 1978

#-------------------------------------------------------
[SOIL]
#-------------------------------------------------------

PathTopo = $(FILE_PATHS:PathMaps)/landsurface/topo
PathSoil1 =  $(FILE_PATHS:PathMaps)/soil

# Topography mapsNetcdf/maps
# tangent slope, slope length and orographybeta 
tanslope  =  $(PathTopo)/tanslope_UB_1km.nc
slopeLength  =  $(PathTopo)/slopeLength_UB_1km.map

# maps of relative elevation above flood plains
relativeElevation  =  $(PathTopo)/dzRel_UB_1km.nc

# Soil hydraulic properties

# soil (Rosetta pedotransfer function)
KSat1  =  $(PathSoil1)/ksat1_UB_1km.map
KSat2  =  $(PathSoil1)/ksat2_UB_1km.map
KSat3  =  $(PathSoil1)/ksat3_UB_1km.map
# Alpha: an Genuchten’s shape parameter
alpha1  =  $(PathSoil1)/alpha1_UB_1km.map
alpha2  =  $(PathSoil1)/alpha2_UB_1km.map
alpha3  =  $(PathSoil1)/alpha3_UB_1km.map
#Lambda: an Genuchten’s shape parameter = n-1-> n = lamda+1, m = 1 - (1/n)
lambda1  =  $(PathSoil1)/lambda1_UB_1km.map
lambda2  =  $(PathSoil1)/lambda2_UB_1km.map
lambda3  =  $(PathSoil1)/lambda3_UB_1km.map
# thetas  is the volumetric water content θ saturated 
thetas1  =  $(PathSoil1)/thetas1_UB_1km.map
thetas2  =  $(PathSoil1)/thetas2_UB_1km.map
thetas3  =  $(PathSoil1)/thetas3_UB_1km.map
# thetar is the volumetric water content θ residual 
thetar1  =  $(PathSoil1)/thetar1_UB_1km.map
thetar2  =  $(PathSoil1)/thetar2_UB_1km.map
thetar3  =  $(PathSoil1)/thetar3_UB_1km.map

percolationImp  =  $(PathSoil1)/percolationImp_UB_1km.map

maxGWCapRise    = 5.0

minCropKC        = 0.2
minTopWaterLayer = 0.0

# Soil depth
StorDepth1  =  $(PathSoil1)/storageDepth1_UB_1km.map
#StorDepth1  =  $(PathSoil1)/storDepth1_totalend.nc
StorDepth2  =  $(PathSoil1)/storageDepth2_UB_1km.map

# preferential flow (between 1.0 and 8.0)
# used in CALIBRATION -> copied to CALIBRATION
#preferentialFlowConstant = 4.0

#-------------------------------------------------------
[LANDCOVER]
PathLandcover = $(FILE_PATHS:PathMaps)/landsurface

coverTypes = forest, grassland, irrPaddy, irrNonPaddy, sealed, water
coverTypesShort = f, g, i, n, s, w
fractionLandcover  =  $(PathLandcover)/fractionLandCover_UB_1km.nc

# Landcover can vary from year to year
dynamicLandcover = True
# if landcover cannot vary, which year should be taken as fixed year
fixLandcoverYear = 1961

forest_fracVegCover  = $(PathLandcover)/fracVegCover0_totalend.nc
#grassland_fracVegCover  = $(PathGrassland)/fracVegCover.map
irrPaddy_fracVegCover  = $(PathLandcover)/fracVegCover2_totalend.nc
irrNonPaddy_fracVegCover  = $(PathLandcover)/fracVegCover3_totalend.nc
#irrigatedArea_original_totalend.nc fracVegCover3_totalend.nc
sealed_fracVegCover = $(PathLandcover)/UBB_built-up_res_2015.nc
water_fracVegCover  =  $(PathLandcover)/fracVegCover5_totalend.nc

Excel_settings_file = $(FILE_PATHS:PathMaps)\settings\cwatm_settings.xlsx

Cotton_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/Cotton_Irr_totalend.nc
SugarAdsali_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/SugarAdsali_Irr_totalend.nc
SugarPreseasonal_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/SugarPreseasonal_Irr_totalend.nc
SugarSuru_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/SugarSuru_Irr_totalend.nc
SorghumK_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/SorghumK_Irr_totalend.nc
SorghumR_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/SorghumR_Irr_totalend.nc
GeneralK_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/GeneralK_Irr_totalend.nc
GeneralR_Irr= $(FILE_PATHS:PathMaps)/landcover/crops/GeneralR_Irr_totalend.nc
Groundnut_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/Groundnut_Irr_totalend.nc
MaizeK_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/MaizeK_Irr_totalend.nc
MaizeR_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/MaizeR_Irr_totalend.nc
FruitVegK_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/FruitVegK_Irr_totalend.nc
FruitVegR_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/FruitVegR_Irr_totalend.nc
SpicesK_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/SpicesK_Irr_totalend.nc
SpicesR_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/SpicesR_Irr_totalend.nc
Soybean_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/Soybean_Irr_totalend.nc
Chickpea_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/Chickpea_Irr_totalend.nc
Wheat_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/Wheat_Irr_totalend.nc

Cotton_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/Cotton_nonIrr_totalend.nc
SugarAdsali_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/SugarAdsali_nonIrr_totalend.nc
SugarPreseasonal_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/SugarPreseasonal_nonIrr_totalend.nc
SugarSuru_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/SugarSuru_nonIrr_totalend.nc
SorghumK_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/SorghumK_nonIrr_totalend.nc
SorghumR_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/SorghumR_nonIrr_totalend.nc
GeneralK_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/GeneralK_nonIrr_totalend.nc
GeneralR_nonIrr= $(FILE_PATHS:PathMaps)/landcover/crops/GeneralR_nonIrr_totalend.nc
Groundnut_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/Groundnut_nonIrr_totalend.nc
MaizeK_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/MaizeK_nonIrr_totalend.nc
MaizeR_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/MaizeR_nonIrr_totalend.nc
FruitVegK_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/FruitVegK_nonIrr_totalend.nc
FruitVegR_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/FruitVegR_nonIrr_totalend.nc
SpicesK_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/SpicesK_nonIrr_totalend.nc
SpicesR_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/SpicesR_nonIrr_totalend.nc
Soybean_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/Soybean_nonIrr_totalend.nc
Chickpea_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/Chickpea_nonIrr_totalend.nc
Wheat_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/Wheat_nonIrr_totalend.nc

GeneralCrop_Irr = $(FILE_PATHS:PathMaps)/landcover/crops/generalIrrCrop_max_totalend.nc
GeneralCrop_nonIrr = $(FILE_PATHS:PathMaps)/landcover/crops/generalnonIrrCrop_max_totalend.nc

crops_leftoverNotIrrigated = 2

#-------------------------------------------------------

[__forest]
PathForest = $(FILE_PATHS:PathMaps)/landcover/forest
PathSoil1 =  $(FILE_PATHS:PathMaps)/soil

# Parameters for the Arno's scheme 
# arnoBeta is defined by orographic,+ land cover add + calibration add, the soil water capacity distribution is based on this 
# range [0.01 - 1.2]
forest_arnoBeta = 0.2

#forest_soil
forest_KSat1  =  $(PathSoil1)/forest_ksat1_UB_1km.map
forest_KSat2  =  $(PathSoil1)/forest_ksat2_UB_1km.map
forest_KSat3  =  $(PathSoil1)/ksat3_UB_1km.map
forest_alpha1  =  $(PathSoil1)/forest_alpha1_UB_1km.map
forest_alpha2  =  $(PathSoil1)/forest_alpha2_UB_1km.map
forest_alpha3  =  $(PathSoil1)/alpha3_UB_1km.map
forest_lambda1  =  $(PathSoil1)/forest_lambda1_UB_1km.map
forest_lambda2  =  $(PathSoil1)/forest_lambda2_UB_1km.map
forest_lambda3  =  $(PathSoil1)/lambda3_UB_1km.map
forest_thetas1  =  $(PathSoil1)/forest_thetas1_UB_1km.map
forest_thetas2  =  $(PathSoil1)/forest_thetas2_UB_1km.map
forest_thetas3  =  $(PathSoil1)/thetas3_UB_1km.map
forest_thetar1  =  $(PathSoil1)/forest_thetar1_UB_1km.map
forest_thetar2  =  $(PathSoil1)/forest_thetar2_UB_1km.map
forest_thetar3  =  $(PathSoil1)/thetar3_UB_1km.map

# other paramater values
forest_minInterceptCap  = 0.001
forest_cropDeplFactor   = 0.0

forest_rootFraction1  =  $(PathForest)/rootFraction1_UB_1km.map

#forest_maxRootDepth  = 2.0
forest_maxRootDepth   =  $(PathForest)/maxRootDepth_UB_1km.map
forest_minSoilDepthFrac  =  $(PathForest)/minSoilDepthFrac_UB_1km.map

forest_cropCoefficientNC  =  $(PathForest)/cropCoefficientForest_10days_UB_1km.nc
forest_interceptCapNC     =  $(PathForest)/interceptCapForest_10days_UB_1km.nc

# initial conditions: forest_interceptStor, forest_w1, forest_w2, forest_w3, 



[__grassland]
PathGrassland = $(FILE_PATHS:PathMaps)/landcover/grassland

# Parameters for the Arno's scheme: 
grassland_arnoBeta = 0.0
# arnoBeta is defined by orographic,+ land cover add + calibration add, the soil water capacity distribution is based on this
# range [0.01 - 1.2]

# other paramater values

grassland_minInterceptCap  = 0.001
grassland_cropDeplFactor   = 0.0


grassland_rootFraction1  =  $(PathGrassland)/rootFraction1_UB_1km.map
grassland_maxRootDepth   =  $(PathGrassland)/maxRootDepth_UB_1km.map
grassland_minSoilDepthFrac  =  $(PathGrassland)/minSoilDepthFrac.map
grassland_cropCoefficientNC  =  $(PathGrassland)/cropCoefficientGrassland_10days_UB_1km.nc
grassland_interceptCapNC     =  $(PathGrassland)/interceptCapGrassland_10days_UB_1km.nc

# initial conditions: grassland_interceptSto, grassland_w1, grassland_w2, grassland_w3


[__irrPaddy]
PathIrrPaddy = $(FILE_PATHS:PathMaps)/landcover/irrPaddy

# Parameters for the Arno's scheme:
irrPaddy_arnoBeta = 0.2
# arnoBeta is defined by orographic,+ land cover add + calibration add, the soil water capacity distribution is based on this
# range [0.01 - 1.2]

# other paramater values

irrPaddy_minInterceptCap  = 0.001
irrPaddy_cropDeplFactor   = 0.0

irrPaddy_rootFraction1  =  $(PathIrrPaddy)/rootFraction1_UB_1km.map
irrPaddy_maxRootDepth   =  $(PathIrrPaddy)/maxRootDepth_UB_1km.map
irrPaddy_minSoilDepthFrac  =  $(PathIrrPaddy)/minSoilDepthFrac.map
irrPaddy_cropCoefficientNC  =  $(PathIrrPaddy)/cropCoefficientirrPaddy_10days_UB_1km.nc

# maximum flooding depth for paddy
irrPaddy_maxtopwater = 0.05

# initial conditions: irrPaddy_interceptStor, irrPaddy_w1, irrPaddy_w2, irrPaddy_w3



[__irrNonPaddy]
PathIrrNonPaddy = $(FILE_PATHS:PathMaps)/landcover/irrNonPaddy

# Parameters for the Arno's scheme:
irrNonPaddy_arnoBeta = 0.2
# arnoBeta is defined by orographic,+ land cover add + calibration add, the soil water capacity distribution is based on this
# range [0.01 - 1.2]

# other paramater values


irrNonPaddy_minInterceptCap  = 0.001
irrNonPaddy_cropDeplFactor   = 0.0

irrNonPaddy_rootFraction1  =  $(PathIrrNonPaddy)/rootFraction1_UB_1km.map
irrNonPaddy_maxRootDepth   =  $(PathIrrNonPaddy)/maxRootDepth_UB_1km.map
irrNonPaddy_minSoilDepthFrac  =  $(PathIrrNonPaddy)/minSoilDepthFrac.map
irrNonPaddy_cropCoefficientNC  =  $(PathIrrNonPaddy)/cropCoefficientirrNonPaddy_10days_UB_1km.nc

# initial conditions: irrNonPaddy_interceptStor, irrNonPaddy_w1, irrNonPaddy_w2, irrNonPaddy_w3


[__sealed]
PathSealed = $(FILE_PATHS:PathMaps)/landcover/sealed

sealed_minInterceptCap  = 0.001

# initial conditions: sealed_interceptStor


[__open_water]
PathWater = $(FILE_PATHS:PathMaps)/landcover/water
water_minInterceptCap  = 0.0

#-------------------------------------------------------
[GROUNDWATER]
#-------------------------------------------------------

PathGroundwater = $(FILE_PATHS:PathMaps)/groundwater

recessionCoeff  =  $(PathGroundwater)/recessionCoeff_UB_1km.map
# baseflow = recessionCoeff * storage groundwater
specificYield  =  $(PathGroundwater)/specificYield_UB_1km.map
kSatAquifer  =  $(PathGroundwater)/kSatAquifer_UB_1km.map
# both not used at the moment in groundwater modul, but already loaded


#-------------------------------------------------------
[GROUNDWATER_MODFLOW]
#-------------------------------------------------------

#Executable Modflow file
path_mf6dll = P:/watmodel/Modflow/mf6

# Path of Modflow input and output
PathGroundwaterModflow = $(FILE_PATHS:PathSystem)/Modflow
#PathGroundwaterModflowOutput = $(PathGroundwaterModflow)/output
PathGroundwaterModflowOutput = $(FILE_PATHS:PathOut)/modflow_outputs 
PathGroundwaterModflowInput = $(PathGroundwaterModflow)/modflow_inputs
#PathGroundwaterModflowInput = $(PathGroundwaterModflow)/500m

# write modflow eror to file
writeModflowError = True

##  --- Steady state begin -----------------------
# soil humidity should not be high when starting to avoid to much pumping demand at the begining (between 0 and 1, 0.75 seems nice)
start_soil_humid = 0.75
# load an initial water table (in meter)
load_init_water_table = True
# if False, initial_water_table_depth (in m) is used on all the grid
initial_water_table_depth = 4
# if True, init_water_table is the initial water table file (2D numpy format (row, col))
init_water_table = $(FILE_PATHS:PathSystem)\Modflow\modflow_inputs\modflow_watertable_totalend.nc

# Defining the upper limit of the groundwater layer
use_soildepth_as_GWtop = False
correct_soildepth_underlakes = True
depth_underlakes = 2

# Pumping file (a 3D numpy array where 1st dim is time, then, 1st col = ModFlow row index, 2nd col = ModFlow col index, 3rd col = pumping rates < 0 !!!! in m3/day)
Groundwater_pumping = True
# if ModFlow cells under the CWatM cell are less saturated than 1-water_table_limit_for_pumping, we prevent pumping
water_table_limit_for_pumping = 0.3

# Prefix of the modflow files
nameModflowModel = Bhima_500m
#ModFlow model's resolution [meter]
Modflow_resolution = 500 #changeResolution

# timestep of every Modflow execution
modflow_timestep = 1

load_modflow_from_disk = False
# Number of layers
nlay = 1


# Data for specified resolution
cwatm_modflow_indices = $(PathGroundwaterModflowInput)/indices
modflow_basin = $(PathGroundwaterModflowInput)/modflow_basin.tif
topo_modflow = $(PathGroundwaterModflowInput)/elevation_modflow.tif
chanRatio = $(PathGroundwaterModflowInput)/modlfow_river_percentage.tif


# We assume a confined aquifer, the unique parameters are transmissivity, porosity and thickness
# Processing thickness map for ModFlow-Flopy format #
# Thickness (default = 400) otherwise use maps from Gleeson et al.
thickness = 50
# Processing porosity map for ModFlow-Flopy format (default = 0.1)
#poro = $(FILE_PATHS:PathMaps)/areamaps/parameter/Poro.txt
#poro = 0.0175
#Processing permeability map for ModFlow-Flopy format (default = 10E-5)
#permeability = $(FILE_PATHS:PathMaps)/areamaps/parameter/Permea.txt
#retro
#permeability = 2.3e-06
#1e-03


# leakage under lake and rivers in m/day
leakageriver_permea = 0.05
leakagelake_permea = 0.05

#-------------------------------------------------------
[WATERDEMAND]
#-------------------------------------------------------
PathWaterdemand = $(FILE_PATHS:PathMaps)/landsurface/waterDemand
# For water demand vs. availability: areas have to be aggregated
# Allocation map
allocSegments = $(PathWaterdemand)/catchx.nc

lift_areas =  $(PathWaterdemand)/lift_command_areas_totalend.nc
#reservoir_command_areas =  $(PathWaterdemand)/pune_pcmc1.tif
reservoir_command_areas =  $(PathWaterdemand)/reservoir_command_areas_totalend.nc
#reservoir_command_areas =  $(PathWaterdemand)/cca_ak_pmc_pcmc.nc
#add_reservoir_command_areas =  $(PathWaterdemand)/PCMC1.tif
canals = $(PathWaterdemand)/Canals_27Aug2020.tif

# Demand in m/day [True] (default) or as mio m3 per year or month [False]
demand_unit = True
adminSegments = $(PathWaterdemand)/2020-10-14_Agents.nc

# Demand data monthly or yearly, as  m day-1 or mio m3 per month
domesticWaterDemandFile  =  $(PathWaterdemand)/domesticWaterDemand_UB_1km.nc
# time = True for monthly, False for yearly
domesticTimeMonthly = True
# name of the variable Withrawal = Gross, consumption = Netto
domesticWithdrawalvarname  =  domesticWithdrawal
domesticConsuptionvarname  =  domesticConsumption

industryWaterDemandFile  =  $(PathWaterdemand)/industryWaterDemand_UB_1km.nc
industryTimeMonthly = True
industryWithdrawalvarname  =  industryWithdrawal
industryConsuptionvarname  =  industryConsumption

uselivestock = True
livestockWaterDemandFile  =  $(PathWaterdemand)/livestockWaterDemand_UB_1km.nc
#livestockWaterDemandFile = $(PathWaterdemand)/livestockWaterDemand.nc
livestockTimeMonthly = True  
livestockvarname = livestockConsumption

# using environmental flow (EF) (per month) as input value
# EF will be treated as one part of overall water demand
use_environflow = False
EnvironmentalFlowFile = $(FILE_PATHS:PathOut)/MQ90_12month.nc

#irrNonPaddy_efficiency = $(FILE_PATHS:PathMaps)/landsurface/waterDemand/efficiency.nc
#irrPaddy_efficiency = $(FILE_PATHS:PathMaps)/landsurface/waterDemand/efficiency.nc
irrNonPaddy_efficiency = 0.7
irrPaddy_efficiency = 0.6
irrigation_returnfraction = 0.6

swAbstractionFraction_Channel_Domestic = 0
swAbstractionFraction_Channel_Livestock = 1
swAbstractionFraction_Channel_Industry = 1
swAbstractionFraction_Channel_Irrigation = 1.0

swAbstractionFraction_Lake_Domestic = 1
swAbstractionFraction_Lake_Livestock = 1
swAbstractionFraction_Lake_Industry = 1
swAbstractionFraction_Lake_Irrigation = 1

swAbstractionFraction_Res_Domestic = 1
swAbstractionFraction_Res_Livestock = 1
swAbstractionFraction_Res_Industry = 0
swAbstractionFraction_Res_Irrigation = 1

gwAbstractionFraction_Domestic = 1
gwAbstractionFraction_Livestock = 1
gwAbstractionFraction_Industry = 1
gwAbstractionFraction_Irrigation = 0.25

#sector-, source-specific abstraction 
commandAreasRelaxGwAbstraction = 0.15
fraction_IncreaseIrrigation_Nonpaddy = 1.2

#gw_agents_month_m3 = $(PathWaterdemand)/gw_11.nc
#sw_agents_month_m3 = $(PathWaterdemand)/sw_11.nc
irrigation_agent_GW_request_month_m3 = $(PathWaterdemand)/gw_11.nc
irrigation_agent_SW_request_month_m3 = $(PathWaterdemand)/sw_11.nc
relax_sw_agent = $(PathWaterdemand)/relaxSWagent_totalend.nc
relax_gw_agent = $(PathWaterdemand)/relaxGWagent_totalend.nc
relax_abstraction_fraction_initial = 0.1

# if activate_domestic_agents = True
domestic_agent_GW_request_month_m3 = $(PathWaterdemand)/urbanWithdrawalGW_max_totalend.nc
domestic_agent_SW_request_month_m3 = $(PathWaterdemand)/urbanWithdrawalSW_max_totalend.nc
domestic_agents_fracConsumptionWithdrawal = 0.2

gw_depth_observations = $(PathWaterdemand)/GroundwaterObservationsKriged_wet_depth.nc
gw_depth_sim_obs = $(PathWaterdemand)/gwdepth_adjuster_totalend.nc
#gwdepth_difference_sim_obs_totalend.nc gwdepth_adjuster_totalend.nc
# ------------------------------------------------------------------
# Estimate of fractions of groundwater and surface water abstractions
# Either a fixed fraction for surface water abstration
# based on fraction of average baseflow and upstream average discharge 
# if swAbstractionFrac < 0: fraction is taken from baseflow / discharge 
# if swAbstractionFrac > 0 this value is taken as a fixed value 
swAbstractionFrac = 0.9

averageDischarge = $(FILE_PATHS:PathOut)/discharge_totalavg.nc
# in [m3/s]
averageBaseflow  = $(FILE_PATHS:PathOut)/baseflow_totalavg.nc
# in [m]
baseflowInM = True
# if baseflow is in [m] instead of [m3/s] it will be converted [TRUE]. If [False] it will be not converted
# -------------------------
# Water Allocation
# Buffer around lakes and reservoirs - water is taken not only from water cells but from
# a rectangular (e.g. 1,3 or 5 please odd numbers) around a waterbody cell
buffer_waterbodies = 3
# Water is taken from surface and groundwater from neighbioring cells, if water is insufficient
# how many cells form a allocation area (e.g. 1,2,3...)
allocation_area = 5
# Farmers do not irrigated to field capacity but to a fraction of it
alphaDepletion = 1.0



# ------------------------------------------------------------------

#-------------------------------------------------------
# RUNOFF CONCENTRATION
#-------------------------------------------------------
[RUNOFF_CONCENTRATION]

# using triagular weigthning method
# the bigger the factor, more lag time 
forest_runoff_peaktime = 1.0
grassland_runoff_peaktime = 0.5
irrPaddy_runoff_peaktime = 0.5
irrNonPaddy_runoff_peaktime = 0.5
sealed_runoff_peaktime = 0.15 
water_runoff_peaktime = 0.01

interflow_runoff_peaktime =1.0
baseflow_runoff_peaktime = 2.0

# initial conditions:
# here only 1 layer is shown, but there are up to 10: runoff_concIni


#-------------------------------------------------------
# ROUTING MAPS and PARAMETERSD
#-------------------------------------------------------
[ROUTING]

PathRouting = $(FILE_PATHS:PathMaps)/routing

# Number of substep per day
# should be 10 for 0.5 deg but 24 for 0.1 deg

NoRoutingSteps = 50
#kinematic wave parameter: 0.6 is for broad sheet flow
chanBeta = 0.6

# Channel gradient (fraction, dy/dx)
chanGrad  =  $(PathRouting)/kinematic/changrad_UB.map
# Minimum channel gradient (for kin. wave: slope cannot be 0)
chanGradMin = 0.0001

#Channel Manning's n
chanMan  =  $(PathRouting)/kinematic/chanmann_UB.map
#Channel length [meters]
chanLength  =  $(PathRouting)/kinematic/chanleng_UB.map
#Channel bottom width [meters]
chanWidth  =  $(PathRouting)/kinematic/chanwidth_UB.map
#Bankfull channel depth [meters]
chanDepth  =  $(PathRouting)/kinematic/chanheight_UB.map

# initial conditions: channelStorageIni, riverbedExchangeIni, dischargeIni  

#-------------------------------------------------------
# LAKES AND RESERVOIRS
#-------------------------------------------------------
[LAKES_RESERVOIRS]

PathLakesRes = $(FILE_PATHS:PathMaps)/routing/lakesreservoirs

# Use reservoirs and lakes (otherwise use only lakes Lake ID=1 and 3 => natural conditions)
useResAndLakes = True
# Reservoirs do have a year of implementation
dynamicLakesRes = True
# if Reservoirs does not have a year of implemtation, which year should be taken as fixed year
fixLakesResYear = 1961


#----------------------------
#Big lakes and Reservoirs

# ID of every lake, reservoir from HydroLakes database
waterBodyID  =  $(PathLakesRes)/WB_FID_27Aug_2.tif
# 1 for lake, 2 for reservoir, 3 for lake and reservoir
waterBodyTyp  =  $(PathLakesRes)/WB_Type_02Oct.tif
# Avergae discharge from HydroLakes Database
waterBodyDis  =  $(PathLakesRes)/WB_Discharge_25Aug.tif

# Lakes surface area from HydroLakes Database 
waterBodyArea  =  $(PathLakesRes)/WB_Area_Mm2_25Aug.tif
# a factor to scale the outlet of a lake
#lakeAFactor = 1.0  -> calibration

#----------------------------
# Small lakes and reservoirs

useSmallLakes = False

smallLakesRes = $(PathLakesRes)/smallLakesRes.nc
smallwaterBodyDis = $(PathLakesRes)/smallLakesResDis.nc

# averageRunoff in [m] (if not given smallwaterBodyDis is taken instead)
#averageRunoff  = $(FILE_PATHS:PathOut)/runoff_totalavg_cali.nc

# initial conditions: lakeInflowIni, lakeStorageIni, outLakeIni, lakeOutflowIni, reservoirStorageIni 

#------------------
# Reservoirs
# reservoir volume from HydroLakes database
waterBodyVolRes  =  $(PathLakesRes)/waterBodyVolRes_totalend.nc
# WB_Volume_28Aug.tif
# reservoir starting year from HydroLakes database 
waterBodyYear  = $(PathLakesRes)/resYear_totalend.nc
#WB_Year_05Sept.tif
waterBodyElec = $(PathLakesRes)/WB_HyElec_25Aug.tif

#  Conservative, normal and flood storage limit (fraction of total storage, [-])
conservativeStorageLimit = 0.1
#normalStorageLimit = 0.5   # --> put into calibration
floodStorageLimit = 0.98
# adjusting the balance between normal and flood storage
# [0 ..1]  0: NormalstorageLimit      1: (= closer to flood) results in keeping the normal qoutflow longer constant
adjust_Normal_Flood = 0.5

# Minimum, Normal and Non-damaging reservoir outflow  (fraction of average discharge, [-])
MinOutflowQ = 0.2
NormalOutflowQ = 1.0
NonDamagingOutflowQ = 4.0

# initial conditions: lakeInflowIni, lakeStorageIni, outLakeIni, lakeOutflowIni, reservoirStorageIni 

#BT_Reservoir_releases = $(FILE_PATHS:PathMaps)/routing/lakesreservoirs/reservoirOperations_Bhima_July6.nc
Reservoir_releases = $(FILE_PATHS:PathMaps)/routing/lakesreservoirs/reservoirOperations_Bhima.nc
Water_conveyance_efficiency = 0.7

#-------------------------------------------------------
[INFLOW]
#-------------------------------------------------------

# if option inflow = true
# the inflow from outside is added at inflowpoints
In_Dir = $(FILE_PATHS:PathRoot)/in

# nominal map with locations of (measured)inflow hydrographs [cu m / s]
InflowPoints = $(In_Dir)/in.map
#InflowPoints = 8.25 49.75 7.75 50.25

# if InflowPoints is a map, this flag is to identify if it is global (False) or local (True)
# observed or simulated input hydrographs as time series [cu m / s]
# Note: that identifiers in time series have to correspond to InflowPoints
# can be several timeseries in one file or different files e.g. main.tss mosel.tss
#QInTS = main1.tss mosel1.tss
QInTS = mm.tss



#-------------------------------------------------------
[ENVIRONMENTALFLOW]
#-------------------------------------------------------

# Either calculate without run with predone discharge (set calc_ef_after = False)
calc_ef_after = True
# Or calculate after run (set calc_ef_after = False) and defining the file to be used
EFDis = $(FILE_PATHS:PathOut)/discharge_rhine.nc
# if predone discharge, do the maps need to be cut to fit to the mask?
cut_ef_map = False


# MAF: Mean, Q90: percentile 90, MMF: monthly average, MQ90: monthly Q90 9averagwed over al Jan, Feb..
# EF_VMF: Environmental flow - variable monthly flow, EF_VMF_LIH - EF- variable monthly flow, high intermediate, low class
OUT_Dir = $(FILE_PATHS:PathOut)
#OUT_MAP_Once = MAF, Q90
#OUT_MAP_12month = MMF, MQ90, EF_VMF, EF_VMF_LIH
#OUT_MAP_12month = MQ90, EF_VMF



#+++++++++++++++++++++++++++++++++++++++++++++++++++++++
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++


[OUTPUT]

# OUTPUT maps and timeseries
OUT_Dir = $(FILE_PATHS:PathOut)

OUT_TSS_Daily = discharge
# irrWithdrawalSW_max, irrWithdrawalGW_max, relaxSWagent, 
OUT_MAP_TotalEnd = frac_totalnonIrr_max, canals, irrWithdrawalSW_max, irrWithdrawalGW_max, resVolume, gwdepth_adjuster, reservoir_command_areas, gwdepth_adjuster, domestic_agent_SW_request_month_m3, domestic_agent_GW_request_month_m3, irrigatedArea_original, reservoir_command_areas, resYear, gwdepth_difference_sim_obs, permeability, relaxGWagent, waterBodyTyp, adminSegments, resVolumeOnlyReservoirs, waterBodyID, cellArea, modflowtotalSoilThickness, GeneralCrop_Irr, GeneralCrop_nonIrr, modflow_watertable, SugarAdsali_Irr
OUT_Map_Daily = discharge
#OUT_Map_Daily = discharge,  lakeResInflowM, act_bigLakeResAbst, lakeResOutflowM, lakeResStorage

#OUT_MAP_Daily = abstractedLakeReservoirM3, Rain, Snow, EWRef, ETRef, WB_elec, humanUse, humanConsumption, ratio_irrWithdrawalGW_month, ratio_irrWithdrawalSW_month, act_nonpaddyConsumption, act_paddyConsumption, act_livConsumption, act_domConsumption, act_indConsumption, returnflowIrr, returnflowNonIrr, GW_Irrigation, Res_Irrigation, Lake_Irrigation, Channel_Irrigation, GW_Industry, GW_Livestock, GW_Domestic, Res_Industry, Res_Livestock, Res_Domestic, Lake_Industry, Lake_Livestock, Lake_Domestic, Channel_Domestic, Channel_Livestock, Channel_Industry, lakebedExchangeM, prefFlow_GW, perc3toGW_GW, leakageIntoGw, leakageIntoRunoff, riverbedExchangeM, leakage, head, act_irrPaddyDemand, act_irrNonpaddyDemand, livestockDemand, industryDemand, domesticDemand, nonIrrDemand, totalIrrDemand, lakeResInflowM, lakeResOutflowM, act_indConsumption, act_domConsumption, act_livConsumption, act_irrWithdrawal, act_nonIrrWithdrawal, act_domWithdrawal, act_indWithdrawal, act_livWithdrawal, snowEvap, Pumping_daily, modfPumpingM, modfPumpingM_actual, modflow_watertable, storGroundwater, groundwater_storage_available, capillar, baseflow, cellArea, actTransTotal_forest, actTransTotal_grasslands, actTransTotal_paddy, actTransTotal_nonpaddy, unmet_lost, unmetDemand, pot_GroundwaterAbstract, discharge, storGroundwater, nonFossilGroundwaterAbs, Precipitation, totalET, EvapoChannel, EvapWaterBodyM, act_nonIrrConsumption, channelStorage, lakeResStorage, totalSto, sum_actTransTotal, sum_actBareSoilEvap, sum_interceptEvap, sum_openWaterEvap, addtoevapotrans, lakeResInflowM, act_bigLakeResAbst, lakeResOutflowM, sum_gwRecharge, sum_capRiseFromGW, baseflow, act_totalIrrConsumption, sum_runoff, returnFlow, act_SurfaceWaterAbstract, actTransTotal_crops_Irr[0], actTransTotal_crops_Irr[1], actTransTotal_crops_Irr[2], actTransTotal_crops_Irr[3], actTransTotal_crops_Irr[4], actTransTotal_crops_Irr[5], actTransTotal_crops_Irr[6], actTransTotal_crops_Irr[7], actTransTotal_crops_Irr[8], actTransTotal_crops_Irr[9], actTransTotal_crops_Irr[10], actTransTotal_crops_Irr[11], actTransTotal_crops_Irr[12], actTransTotal_crops_Irr[13], actTransTotal_crops_Irr[14], actTransTotal_crops_Irr[15], actTransTotal_crops_Irr[16], actTransTotal_crops_Irr[17]

#OUT_Map_MonthAvg = lakeResStorage, act_irrWithdrawal, discharge, ETRefAverage_segments, precipEffectiveAverage_segments, lakeResStorage

OUT_Map_MonthTot = PumpingM3_daily, abstractedLakeReservoirM3, ETRefAverage_segments, precipEffectiveAverage_segments, lakeResInflowM, act_bigLakeResAbst, lakeResOutflowM, EvapWaterBodyM, leakage

#OUT_Map_MonthEnd = lakeResStorage, totalSto, channelStorage, gwdepth_adjusted_segments, gwdepth_adjusted, irrM3_Paddy_month_segment, irrM3_crop_month_segment[0], irrM3_crop_month_segment[1], irrM3_crop_month_segment[2], irrM3_crop_month_segment[3], irrM3_crop_month_segment[4], irrM3_crop_month_segment[5], irrM3_crop_month_segment[6], irrM3_crop_month_segment[7], irrM3_crop_month_segment[8], irrM3_crop_month_segment[9], irrM3_crop_month_segment[10], irrM3_crop_month_segment[11], irrM3_crop_month_segment[12], irrM3_crop_month_segment[13], irrM3_crop_month_segment[14], irrM3_crop_month_segment[15], irrM3_crop_month_segment[16], irrM3_crop_month_segment[17], modflow_head_adjusted, ratio_irrWithdrawalGW_month, ratio_irrWithdrawalSW_month, act_irrWithdrawalSW_month, act_irrWithdrawalGW_month, relaxSWagent, relaxGWagent, frac_totalIrr_max, frac_totalnonIrr_max, modflow_watertable, gwdepth, gwdepth_segments, head, head_segments, totalPotET_month_segment[0], totalPotET_month_segment[1], totalPotET_month_segment[2], totalPotET_month_segment[3], totalPotET_month_segment[4], totalPotET_month_segment[5], totalPotET_month_segment[6], totalPotET_month_segment[7], totalPotET_month_segment[8], totalPotET_month_segment[9], totalPotET_month_segment[10], totalPotET_month_segment[11], totalPotET_month_segment[12], totalPotET_month_segment[13], totalPotET_month_segment[14], totalPotET_month_segment[15], totalPotET_month_segment[16], totalPotET_month_segment[17], availableArableLand, fracVegCover[0], fracVegCover[1], fracVegCover[2], fracVegCover[3], fracVegCover[4], fracVegCover[5], frac_totalIrr, frac_totalnonIrr, fracCrops_Irr[0],  fracCrops_Irr[1], fracCrops_Irr[2], fracCrops_Irr[3], fracCrops_Irr[4], fracCrops_Irr[5], fracCrops_Irr[6], fracCrops_Irr[7], fracCrops_Irr[8], fracCrops_Irr[9], fracCrops_Irr[10], fracCrops_Irr[11], fracCrops_Irr[12], fracCrops_Irr[13], fracCrops_Irr[14], fracCrops_Irr[15], fracCrops_Irr[16], fracCrops_Irr[17], fracCrops_nonIrr[0], fracCrops_nonIrr[1], fracCrops_nonIrr[2], fracCrops_nonIrr[3], fracCrops_nonIrr[4], fracCrops_nonIrr[5], fracCrops_nonIrr[6], fracCrops_nonIrr[7],  fracCrops_nonIrr[8], fracCrops_nonIrr[9], fracCrops_nonIrr[10], fracCrops_nonIrr[11], fracCrops_nonIrr[12], fracCrops_nonIrr[13], fracCrops_nonIrr[14], fracCrops_nonIrr[15], fracCrops_nonIrr[16], fracCrops_nonIrr[17], fracCrops_IrrLandDemand[0],  fracCrops_IrrLandDemand[1], fracCrops_IrrLandDemand[2], fracCrops_IrrLandDemand[3], fracCrops_IrrLandDemand[4], fracCrops_IrrLandDemand[5], fracCrops_IrrLandDemand[6], fracCrops_IrrLandDemand[7],fracCrops_IrrLandDemand[8], fracCrops_IrrLandDemand[9], fracCrops_IrrLandDemand[10], fracCrops_IrrLandDemand[11], fracCrops_IrrLandDemand[12], fracCrops_IrrLandDemand[13], fracCrops_IrrLandDemand[14], fracCrops_IrrLandDemand[15], fracCrops_IrrLandDemand[16], fracCrops_IrrLandDemand[17], fracCrops_nonIrrLandDemand[0],  fracCrops_nonIrrLandDemand[1], fracCrops_nonIrrLandDemand[2], fracCrops_nonIrrLandDemand[3], fracCrops_nonIrrLandDemand[4], fracCrops_nonIrrLandDemand[5], fracCrops_nonIrrLandDemand[6], fracCrops_nonIrrLandDemand[7], fracCrops_nonIrrLandDemand[8], fracCrops_nonIrrLandDemand[9], fracCrops_nonIrrLandDemand[10], fracCrops_nonIrrLandDemand[11], fracCrops_nonIrrLandDemand[12], fracCrops_nonIrrLandDemand[13], fracCrops_nonIrrLandDemand[14], fracCrops_nonIrrLandDemand[15], fracCrops_nonIrrLandDemand[16], fracCrops_nonIrrLandDemand[17], fallowIrr, fallownonIrr, GeneralCrop_Irr, GeneralCrop_nonIrr, areaPaddy_Irr_segment, areaCrops_Irr_segment[0], areaCrops_nonIrr_segment[0], areaCrops_Irr_segment[1], areaCrops_nonIrr_segment[1], areaCrops_Irr_segment[2], areaCrops_nonIrr_segment[2], areaCrops_Irr_segment[3], areaCrops_nonIrr_segment[3], areaCrops_Irr_segment[4], areaCrops_nonIrr_segment[4], areaCrops_Irr_segment[5], areaCrops_nonIrr_segment[5], areaCrops_Irr_segment[6], areaCrops_nonIrr_segment[6], areaCrops_Irr_segment[7], areaCrops_nonIrr_segment[7], areaCrops_Irr_segment[8], areaCrops_nonIrr_segment[8], areaCrops_Irr_segment[9], areaCrops_nonIrr_segment[9], areaCrops_Irr_segment[10], areaCrops_nonIrr_segment[10], areaCrops_Irr_segment[11], areaCrops_nonIrr_segment[11], areaCrops_Irr_segment[12], areaCrops_nonIrr_segment[12], areaCrops_Irr_segment[13], areaCrops_nonIrr_segment[13], areaCrops_Irr_segment[14], areaCrops_nonIrr_segment[14], areaCrops_Irr_segment[15], areaCrops_nonIrr_segment[15] , areaCrops_Irr_segment[16], areaCrops_nonIrr_segment[16],  areaCrops_Irr_segment[17], areaCrops_nonIrr_segment[17], availableArableLand, availableArableLand_segment 


#OUT_MAP_TotalTot = Precipitation
